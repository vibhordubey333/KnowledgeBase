# Kibana
- Version `kibana-7.17.4`
- To run below commands use DevTools in Kibana
    - Click on hamburger button on left side.
    - Scroll down to bottom and under "Management" click on `Dev Tools`

### APIs To Interact With ElasticSearch From Kibana

1. **GET _cluster/health**
    ##### Output
   ```{
   "cluster_name" : "vibhor.tests",
   "status" : "yellow",
   "timed_out" : false,
   "number_of_nodes" : 1,
   "number_of_data_nodes" : 1,
   "active_primary_shards" : 12,
   "active_shards" : 12,
   "relocating_shards" : 0,
   "initializing_shards" : 0,
   "unassigned_shards" : 3,
   "delayed_unassigned_shards" : 0,
   "number_of_pending_tasks" : 0,
   "number_of_in_flight_fetch" : 0,
   "task_max_waiting_in_queue_millis" : 0,
   "active_shards_percent_as_number" : 80.0
   }```

2. **GET _nodes/stats**   
    Pasting only few lines. `stats` API helps in debugging nodes.
    #### Output
    ```{
   "_nodes" : {
   "total" : 1,
   "successful" : 1,
   "failed" : 0
   },
   "cluster_name" : "vibhor.tests",
    }

3. **PUT favorite_laptop**
   #### Output
    ```
    {
    "acknowledged" : true,
    "shards_acknowledged" : true,
    "index" : "favorite_laptop"
    }
   ```
4. **POST favorite_laptop/_doc
   {
   "laptop_model" : "A-17",
   "laptop_brand": "Asus"
   }**   
    ####Output
    ```
    {
    "_index": "favorite_laptop",
    "_id": "vOorW4EBb-V9pMSeMgL8",
    "_version": 1,
    "result": "created",
    "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
    },
    "_seq_no": 0,
    "_primary_term": 1
    }
    ```
5. In 4th point we can see "_id" field is having an auto-generated value but if we want to assign 
   a value generated by us then need to mention ID in path parameter.
   
   **POST favorite_laptop/_doc/2
   {
   "laptop_model" : "A-15",
   "laptop_brand": "Asus",
   "id": "002"
   }** 
    #### Output
    ```
    {
    "_index" : "favorite_laptop",
    "_id" : "2",
    "_version" : 1,
    "result" : "created",
    "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
    },
    "_seq_no" : 7,
    "_primary_term" : 1
    }
    ```
6. In continuation to point 5, let's fetch the document by ID.
   **GET favorite_laptop/_doc/1**
    #### Output
    ```
     {
    "_index" : "favorite_laptop",
    "_id" : "1",
    "_version" : 4,
    "_seq_no" : 6,
    "_primary_term" : 1,
    "found" : true,
    "_source" : {
    "laptop_model" : "A-16",
    "laptop_brand" : "Asus",
    "id" : "0111"
    }
    }

    ```
7. We can create document whether using PUT or POST method. But PUT is 
   best suited for updating already existing documents until peculiar scenario 
   comes.
   
   **PUT favorite_laptop/_doc/3
   {
   "laptop_model" : "A-15",
   "laptop_brand": "Asus",
   "id": "003"
   }**
   ```
   {
   "_index" : "favorite_laptop",
   "_id" : "3",
   "_version" : 1,
   "result" : "created",
   "_shards" : {
   "total" : 2,
   "successful" : 1,
   "failed" : 0
   },
   "_seq_no" : 8,
   "_primary_term" : 1
   }
   ``` 
8. To fetch our document using the ID.
   **GET favorite_laptop/_doc/1**
   ```
   {
   "_index" : "favorite_laptop",
   "_id" : "1",
   "_version" : 4,
   "_seq_no" : 6,
   "_primary_term" : 1,
   "found" : true,
   "_source" : {
   "laptop_model" : "A-16",
   "laptop_brand" : "Asus",
   "id" : "0111"
   }
   }
   ```
9. To avoid over-writing a document which already exists use `_create`
   
   **PUT favorite_laptop/_create/1
    {
    "laptop_model" : "A-15",
    "laptop_brand": "Asus",
    "id": "004"
    }**
   ```
   {
   "error" : {
   "root_cause" : [
   {
   "type" : "version_conflict_engine_exception",
   "reason" : "[1]: version conflict, document already exists (current version [4])",
   "index_uuid" : "ivqHqYEPQdKsEB9DSUL7Jg",
   "shard" : "0",
   "index" : "favorite_laptop"
   }
   ],
   "type" : "version_conflict_engine_exception",
   "reason" : "[1]: version conflict, document already exists (current version [4])",
   "index_uuid" : "ivqHqYEPQdKsEB9DSUL7Jg",
   "shard" : "0",
   "index" : "favorite_laptop"
   },
   "status" : 409
   }
   ```
10. To update certain field of the document, use `_update` property.
    **POST favorite_laptop/_update/1
    {
    "doc":{
    "laptop_brand": "Lenovo"
    }
    }**
   ```
   {
  "_index" : "favorite_laptop",
  "_id" : "1",
  "_version" : 5,
  "_seq_no" : 15,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "laptop_model" : "A-15",
    "laptop_brand" : "Lenovo",
    "id" : "001"
  }
}

   ```
   
      
12. To delete document.
    
   **DELETE favorite_laptop/_doc/1**
   ```
   {
   "_index" : "favorite_laptop",
   "_id" : "1",
   "_version" : 3,
   "result" : "deleted",
   "_shards" : {
   "total" : 2,
   "successful" : 1,
   "failed" : 0
   },
   "_seq_no" : 13,
   "_primary_term" : 1
   }
   ```

#### Notes
   
1. In point 4 you will see field as `_version" : 4` it means document has been over-written 4 times
   since it has been created.
2. How ElasticSearch is different from RDBMS databases ?
   - Elastic search is not a DB it does store documents but it is a search and analytics engine. ElasticSearch is schema free and it is built upon Apache
      Lucene. So it is designed to excel as full text searches
   
3. Difference between MongoDB and ElasticSearch
   > MongoDB is an opensource document-oriented Database Management System. Elasticsearch is Apache Lucene based RESTful real-time search and analytics engine.
   There are certain features like Document-oriented Store, Schema free, Distributed Data Storage, High-Availability, Sharding, Replication etc., which 
   are common in both products. And though, it is possible to use Elasticsearch as a primary data-store, the use case to be implemented is a key in 
   deciding which product to be used.
   If you look at the way MongoDB and Elasticsearch are evolving, you will understand that they cater to different use cases. 
   MongoDB tries to provide a NoSQL DBMS for storing huge amount (humongous - that's where name Mongo comes from) of data. Elasticsearch, on the other hand, provides capability to store, index, search and analyze data in real-time which lets you extract value from the data. This data could be stored directly in Elasticsearch cluster or collected from various other data sources, including MongoDB.
   - Below are some differences in MongoDB and Elasticsearch
       - **Indexing** - Elasticsearch uses Apache Lucene for indexing while MongoDB indexes are based on traditional B+ Tree. Real-time indexing and 
                     searching power of Elasticsearch comes from Lucene, which allows creation of index on every field of a document by default. In MongoDB, we have to 
                     define the index, which improves query performance, but affects write operations.
       - **Language** - Elasticsearch is implemented in Java, while MongoDB is implemented in C++
       - **Documents** - Elasticsearch stores JSON documents, while MongoDB stores them in BSON (Binary JSON) format. (though, it looks exactly like a JSON document to the end user)
       - **REST Interface** - Elasticsearch is RESTful. MongoDB is not RESTful.
       - **MapReduce** - MongoDB allows MapReduce operations on the data. Elasticsearch does not have support for MapReduce.
4. Do the node uses cache to find the data that is being searched ?
   - Yes.
5. What is the best way to perform sharding with one node ?
   - It is not recommended as if your node goes down then your data is lost forever.
6. Cons of using ElasticSearch ?
   - Doesn't support joins.
   - 
7. Does elasticsearch support secure communications on `:9200` and `:5601` port ?
   - Yes, we can add use authentication/tokens to secure.


#### References
1. https://github.com/LisaHJung
2. https://www.quora.com/What-are-the-main-differences-between-ElasticSearch-and-NoSQL-DBs-like-MongoDB-Do-you-think-these-two-technologies-products-would-have-more-similarities-than-differences-in-the-near-future
3. https://cloud.netapp.com/blog/cvo-blg-elasticsearch-vs-mongodb-6-key-differences#:~:text=Elasticsearch%20is%20built%20for%20search,data%20in%20a%20distributed%20architecture.
4. 